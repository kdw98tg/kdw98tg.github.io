---
title: "[Design Pattern] 전략 패턴 (Strategy Pattern)"

categories:
  -  Design Pattern
  
tags:
  - [Java, Head-First Design Pattern]

toc: true
toc_sticky: true

date: 2023-05-12
last_modified_at: 2024-03-01
---



## 전략 패턴이란?

> 전략패턴 (Strategy Pattern)은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 할 수 있는 패턴 입니다. 
> 
> 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.

즉, 전략패턴은 알고리즘의 변화에 따라 동적으로 알고리즘을 선택할 수 있도록 해주며, 유연성과 확장성을 제공합니다.

### 전략 패턴이 사용되는 곳
- 동일한 문제를 해결하는 여러 알고리즘이 존재할 때
- 알고리즘을 사용하는 클라이언트와 알고리즘을 분리하고자 할 때
- 실행 중에 알고리즘을 교체할 때

### 전략패턴의 이점
- `유연성` : 알고리즘을 필요에 따라 교체하기 쉬움
- `확장성` : 새로운 전략을 추가하기 쉬움
- `코드 재사용` : 필요한 알고리즘을 재사용할 수 있음

전략패턴은 다음과 같은 디자인 원칙을 따릅니다.

### 디자인 원칙
> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 곳과 분리한다.

**즉, 바뀌는 부분은 따로 뽑아서 캡슐화 하는 것입니다. 그렇다면 나중에 바뀌지 않는 부분에는 영향을 주지 않고, 바뀌어야 하는 부분을 고치거나 확장을 하기 쉽습니다.**

## 예제

여러가지의 오리를 구현해봅시다.

오리에는 여러가지 종류가 있습니다.

`진짜 오리`, `나무오리`, `러버덕`, `날지 못하는 오리`, `시기에 따라 사는곳을 옮기는 오리` 등등 여러가지 오리가 있습니다.

이것들을 막연하게 구현하려면, 각 클래스마다 오리의 행동을 정의해야 합니다.

하지만, 이렇게 하면 모든 구상클래스에서 오리의 행동을 정의해야 합니다.

지금은 5개정도의 오리를 구현하기 때문에 각기 클래스마다 정의해서 사용해도 되지만, 이 오리 클래스가 100개 ... 10000개 가 되어버리면, 유지보수가 불가능한 수준이 되어 버립니다.

그렇기 때문에 전략패턴을 구현해서, 해당 로직을 구현합니다.

이때, `객체지향의 다형성` 을 이용하여 전략 패턴을 구현합니다.


```java
public interface 123123 {
	fun duck();
}

public class FlyNoWay implements FlyBehaviour
{
	@override
	public void fly(){
	System.out.print("123");
	}
}
```





