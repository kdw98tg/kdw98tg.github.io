---
title: "[Refactoring] 리팩터링 2판 Chapter.09 part 1 (데이터 조직화)"

categories:
  -  Refactoring
  
tags:
  - [Refactoring, javascript]

toc: true
toc_sticky: true

published: false

date: 2025-01-12
last_modified_at: 2025-01-12
---

이번 챕터는 변수와 관련된 내용입니다. 이번 파트도 마찬가지로, 새로운 개념보다는 이미 사용하고 있는 개념들을 점검하는 파트 입니다. (예제는 생략했습니다.)

## 변수 쪼개기

여기서 말하는 변수 쪼개기란, 역할이 둘 이상인 변수가 있다면 쪼개라는 뜻입니다. 예외는 없습니다.

책에있는 예제를 보면서 이렇게 코딩하는 사람이 있나? 라고 생각했는데, 책에 실릴 정도면 꽤 많은것 같습니다.

다음과 같은 경우 입니다.

```cs
private int Main(){
	int temp = 2 * (height + width);
	Console.WriteLine(temp);
	temp = height * width;
	return temp;
}
```

보기만해도 끔찍하군요. 

이걸 리팩터링이 아닌 `정상화`하면 다음과 같습니다.

```cs
private int Main(){
	int perimeter = 2 * (height + width);
	Console.WriteLine(temp);
	int area = height * width;
	return temp;
}
```

민망할정도로 당연한 리팩터링이었습니다.

### 절차
1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.
2. 가능하면 이때 불변으로 선언한다.
3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름으로 바꾼다.
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다.
5. 테스트한다.
6. 반복한다.

## 필드 이름 바꾸기

이것역시 민망할 정도로 당연한 개념입니다. 

프로그래밍에서 `이름`은 가장 중요한 역할을 합니다. 이름만으로 코드를 이해하지 않고도 어떤 기능을 하는지 알 수 있기 때문입니다. 따라서 이름을 잘 짓는것이 중요합니다..

## 파생 변수를 질의 함수로 바꾸기

가변데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫거리에 속합니다. 가변 데이터는 서로 다른 두 코드를 이상한 방식으로 결합하기도 하는데, 예컨대 한 쪽 코드에서 수정한 값이 연쇄 효과를 일으켜 다른 쪽 코드에 원일을 찾기 어려운 문제를 만들기도 합니다.

가변데이터를 완전히 배제하기란 불가능에 가깝지만, 유효범위를 가능한 좁혀야 합니다.

### 절차

1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다.
2. 해당 변수의 값을 계산해주는 함수를 만든다.
3. 해당 변수가 사용되는 모든 곳에 Assert를 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다.
4. 테스트한다.
5. 변수를 읽는 코드를 모두 함수 호출로 대체한다.
6. 테스트한다.
7. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다.



