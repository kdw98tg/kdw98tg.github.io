1강 2강 듣고 다시 함 보자

https://pinkyeti.tistory.com/18

jsx = html + js

const element = `<h1>hello, world!</h1>` 처럼 생김

jsx에서 좀 다름
class = className
for - htmlFor
onclick - onClick

jsx에서는 반드시 하나의 요소로 묶여 있어야 함

false 는 랜더링 안됨
&&를 쓰면 앞에꺼가 참이면 뒤에 문자열이 있다? 그러면 문자열을 출력함

js !! 연산자 보기

react에서 and or 연산자 많이 씀 

key 속성은 요소를 나열할 때 사용함
리엑트에서는 아이템들에 다 key를 달아줘야함

index로 키를 주면 문제가 생길 수 있음
공식적으로 권장하지는 않음
순서가 변경되는게 아니라는게 보장되면 걍 씀

스타일을 넣을때는 js 오브젝트를 넣는식으로 넣음
오브젝트로 만들어지는 스타일들은 카멜케이스를 사용함

css파일을 넣으려면 맨 위에 
`import ./index.css` 를 사용하면 됨
class 는 className으로 바뀌게 됨

css in js 라고 부름

jsx에서 람다식은 {}로 하면 무조건 return 값이 있어야 하고
()는 암묵적 리턴임

```js
const num = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const element = (
  <div style={{ display: 'flex' }}>
    {num.map(
      (n) =>
        n !== 1 &&
        n !== 5 &&
        <div style={{ padding: 10, color: n % 2 === 1 ? "blue" : "black" }}>
          {num.map((m) => {
            return <div>
              {n} x {m} = {n * m}
            </div>
          })}
        </div>
    )}
  </div>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

컴포넌트
하나의 jsx를 반환하는 함수를 말함
컴포넌트를 App.js에서 익스포트 하고
그거를 태그처럼 사용할 수 있음

js 확장자 안써도 됨
컴포넌트 만들어서 붙일 수 있음
import export 문법 보기

컴포넌트 주의사항
- 항상 파스칼 케이스
- 컴포넌트를 의미단위로 쪼갬 (App - Page - Header, Banner, RecentLectureSection 등)
- 최상위 컴포넌트 이름은 App
- 컴포넌트라는 폴더를 만들고 그 안에 컴포넌트들을 모아둠

Props (Properties)
 부모 컴포넌트에서 자식 컴포넌트로 내려주는 데이터
 - 구조분해 할당 구문을 잘 활용하자
 - 특정 Props에 기본 값을 줄 수 있음
 - Props는 readonly임
```js
import Heading from './components/Heading';

function App() {
  return (
    <div>
      <Heading type="h1">Hello</Heading>
      <Heading type="h2">World</Heading>
    </div>
  )
}
```

```js
export default function Heading(props) {
    if (props.type === "h2") {
        return <h2>{props.children}</h2>
    }
    return <h1>{props.children}</h1>;
}
```

State

컴포넌트 내부에서 사용되는 변수

State 값이 변하면 컴포넌트가 리렌더링 됨
렌더링 사이클에서 값이 보존됨

```js
// value를 state로 만들기
// Increase 버튼 함수 만들기 
// Reset 버튼 함수 만들기

//한번 박히면 value= 0으로 박혀있음
//그래서 값이 변하면 리랜더링해주는 과정이 필요함
// export default function App() {
//   let value = 0;
//   return (
//     <div>
//       <h1>value: {value}</h1>
//       <button onClick={() => {
//         console.log("Increase value");
//         value += 1;
//       }}>
//         Increase value</button>
//       <button>Reset value</button>
//     </div>
//   )
// }

import { useState } from 'react'

export default function App() {
  //useState는 배열을 반환함
  //첫번째 요소는 state 의 자체 값
  //두번째 요소는 함수임
  //setter함수이고, setter를 통해 변경하면 콜백이 일어나서 리랜더링함
  //useState 안에는 초기값을 넣어줌

  //모든 랜더링이 끝나고 마지막에 콜백이 올라감
  //타이밍 중요
  const [value, setValue] = useState(0);
  return (
    <div>
      <h1>value: {value}</h1>
      <button onClick={() => {
        console.log("Increase value");
        setValue(value + 1);
      }}>
        Increase value</button>
      <button onClick={() => {
        setValue(0);
      }}>Reset value</button>
    </div>
  )
}
```


클래스형 컴포넌트
클래스 문법으로 구현한 컴포넌트

useState와 같은 Hooks는 React 버전 16.8부터 등장
즉, 그 전에는 함수형 컴포넌트에서 state를 사용할 수 없었고, 클래스형 컴포넌트만 state를 가질 수 있었음
클래스의 멤버 변수로 state 정의
render라는 멤버 함수에서 반환한 값이 화면에 그려짐

```js
import React, { Component } from 'react';

export default class App extends Component {
  state = {
    value1: 0,
    value2: 0
  };

  // const [value1, setValue1]=useState(0);
  // const [value2, setValue2]=useState(0);

  constructor(props) {
    super(props);

    //초기화
    this.state = {
      value: 1
    };
  }

  //멤버 함수에다가 정의 가능
  resetValue() {
    this.setState({ value: 0 });
  }

  render() {
    return (
      <div>
        <h1>value : {this.state.value}</h1>
        <button onClick={()=>{
          this.setState((state)=>({
            value: state.value +1
          }))
        }}> Increase Button </button>

         <button onClick={()=>{
          //bind는 this바인딩 문제
          //클래스 요소가 아니라 button의 포인터가 들어감
          //App class의 포인터를 바인딩 해줘야 함
          this.setState(this.resetValue.bind(this))
        }}> Reset Button </button>
      </div>
    )
  }


}
```

초기에는 클래스형 컴포넌트가 기본임
하지만 클래스형 컴포넌트 몇가지 문제로 인해 새로운 방식 고안
지금은 Hooks가 완전히 정착하여 기본형으로 사용되고 있음